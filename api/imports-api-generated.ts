/* tslint:disable */
/* eslint-disable */
/*
Timmi Absences API

Welcome on the documentation for Timmi Absences API.

The version of the OpenAPI document: 1.0
Contact: developers@lucca.fr

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ImportsAbsenceBatchCreateResponse } from '../models';
// @ts-ignore
import { ImportsCreateAbsencesBatchRequest } from '../models';
// @ts-ignore
import { ImportsCreateAbsencesBatchResponse } from '../models';
// @ts-ignore
import { ImportsEntitlementsBatchImportRequest } from '../models';
// @ts-ignore
import { ImportsEntitlementsBatchImportResponse } from '../models';
// @ts-ignore
import { ImportsImportLeaveEntitlementsRequest } from '../models';
// @ts-ignore
import { ImportsReplaceEntitlementsRequest } from '../models';
// @ts-ignore
import { ImportsReplaceEntitlementsRequest1 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ImportsApi - axios parameter creator
 * @export
 */
export const ImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**   **File format**  Type: CSV (with semicolon \";\")  Encoding: UTF-8   All the following fields must be present with the field name in the header:  - legalEntity : establishment of the employee - employeeNumber : employee number - lastName : last name of the employee - firstName : firstname of the employee - accountId : absence account id in Timmi Absences (you can find it in the leave accounts admin page) - startDate : absence start date (DD/MM/YYYY) - flagStartDate : AM (if the absences starts in the morning) or PM (if the absence starts in the afternoon) - endDate : absence end date (DD/MM/YYYY) - flagEndDate : AM (if the absences ends at noon) or PM (if the absences ends in the afternoon) - isApproved : yes or no. Compulsory if the absence type is subject to approval, optional otherwise.  **History** Import history is available in the import module, including imports made using the API. 
         * @summary Import leaves (deprecated)
         * @param {'csv'} type Support CSV files only
         * @param {string} originalFileName Filename
         * @param {boolean} [create] Use &#x60;false&#x60; to simulate the import.
         * @param {boolean} [recredit] Use &#x60;true&#x60; if absences should **not** be deducted from the user balance. Use &#x60;false&#x60; if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case.
         * @param {boolean} [synchronize] Use &#x60;true&#x60; to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use &#x60;false&#x60; to import absences without synchronizing absences.
         * @param {boolean} [overrideLeaves] Use &#x60;true&#x60; to allow replacing existing absences
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        absenceBatchCreate: async (type: 'csv', originalFileName: string, create?: boolean, recredit?: boolean, synchronize?: boolean, overrideLeaves?: boolean, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('absenceBatchCreate', 'type', type)
            // verify required parameter 'originalFileName' is not null or undefined
            assertParamExists('absenceBatchCreate', 'originalFileName', originalFileName)
            const localVarPath = `/api/v3/services/importLeavePeriods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }

            if (recredit !== undefined) {
                localVarQueryParameter['recredit'] = recredit;
            }

            if (originalFileName !== undefined) {
                localVarQueryParameter['originalFileName'] = originalFileName;
            }

            if (synchronize !== undefined) {
                localVarQueryParameter['synchronize'] = synchronize;
            }

            if (overrideLeaves !== undefined) {
                localVarQueryParameter['overrideLeaves'] = overrideLeaves;
            }


    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v3/services/importLeavePeriods',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**  **File format**  Content-Type: CSV. Column divider is semicolon \";\". Line breaks between rows.  Encoding: UTF-8  All the following fields must be present with the field name in the header:  - legalEntity: Name of the establishment the employee belongs to. - employeeNumber: Employee number. - lastName: Family (last) name of the employee. - firstName: Given (first) name of the employee. - accountId: Identifier of the absence account in Timmi Absences (can be found in the leave accounts admin page). - startDate: Start date of the absence, formatted as `DD/MM/YYYY`. - flagStartDate: `\"AM\"` if the absence starts in the morning or `\"PM\"` if the absence starts in the afternoon. - endDate: End date of the absence, formatted as `DD/MM/YYYY`. - flagEndDate: `\"AM\"` if the absence ends at noon or `\"PM\"` if the absence ends in the afternoon. - isApproved: `true` or `false`. Dictates whether the absence request should be created and already approved.    Required if the type of the absence requires approval, optional otherwise.  **History** Import history is available in the import module. It includes imports made via the API. 
         * @summary Import leaves
         * @param {boolean} [create] Use &#x60;false&#x60; to simulate the import.
         * @param {boolean} [recredit] Use &#x60;true&#x60; if absences should **not** be deducted from the user balance. Use &#x60;false&#x60; if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case.
         * @param {string} [originalFileName] Filename
         * @param {boolean} [synchronize] Use &#x60;true&#x60; to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use &#x60;false&#x60; to import absences without synchronizing absences.
         * @param {boolean} [async] Use &#x60;true&#x60; if you want to import absences with the asynchronous processing (you have to request figgo/api/imports/v1.0/leavePeriods/{summaryId}/progress API to track the status). Use &#x60;false&#x60; if you want import absences with the synchronous processing (the response is sent when the file is fully imported).
         * @param {Array<string>} [files] 
         * @param {ImportsCreateAbsencesBatchRequest} [importsCreateAbsencesBatchRequest] Content of the CSV file to import. Each file in its dedicated part of the multipart request. Parts are divided by the \&#39;boundary\&#39; string set in the Content-Type HTTP header.  Example of a single file request body: &#x60;&#x60;&#x60; --myBoundary Content-Disposition: form-data; name&#x3D;\&quot;figgo-import-5875e9dd-0b1f-4a9f-8756-0f25fb0a2946.csv\&quot;; filename&#x3D;\&quot;figgo-import-5875e9dd-0b1f-4a9f-8756-0f25fb0a2946.csv\&quot; Content-Type: application/vnd.ms-excel  legalEntity;employeeNumber;lastName;firstName;accountId;startDate;flagStartDate;endDate;flagEndDate;isApproved Lucca FR;M0029;Bart;Maurice;1322;16/08/2022;am;17/08/2022;pm;true Lucca FR;M0029;Bart;Maurice;1322;22/08/2022;am;23/08/2022;pm;false Lucca FR;M0029;Bart;Maurice;8;29/08/2022;am;30/08/2022;pm;true --myBoundary-- &#x60;&#x60;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbsencesBatch: async (create?: boolean, recredit?: boolean, originalFileName?: string, synchronize?: boolean, async?: boolean, files?: Array<string>, importsCreateAbsencesBatchRequest?: ImportsCreateAbsencesBatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timmi-absences/api/imports/v1.0/leavePeriods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }

            if (recredit !== undefined) {
                localVarQueryParameter['recredit'] = recredit;
            }

            if (originalFileName !== undefined) {
                localVarQueryParameter['originalFileName'] = originalFileName;
            }

            if (synchronize !== undefined) {
                localVarQueryParameter['synchronize'] = synchronize;
            }

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

        if (files) {
                const baseName = 'files'
                for (const element of files) {
                    await addFormParam(baseName, element, false, false)
                }
            }

    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: importsCreateAbsencesBatchRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timmi-absences/api/imports/v1.0/leavePeriods',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements (deprecated)
         * @param {boolean} [strict] In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
         * @param {boolean} [simulate] Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
         * @param {string} [file] 
         * @param {string} [description] Description of the entries generated by the import (visible to users in the account details).
         * @param {string} [referenceDate] Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
         * @param {ImportsEntitlementsBatchImportRequest} [importsEntitlementsBatchImportRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        entitlementsBatchImport: async (strict?: boolean, simulate?: boolean, file?: string, description?: string, referenceDate?: string, importsEntitlementsBatchImportRequest?: ImportsEntitlementsBatchImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/figgo/api/public/services/v1.0/leaveEntitlementsImport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (simulate !== undefined) {
                localVarQueryParameter['simulate'] = simulate;
            }


            if (file !== undefined) {
                await addFormParam('File', file, false, true)
            }
    
            if (description !== undefined) {
                await addFormParam('Description', description, false, true)
            }
    
            if (referenceDate !== undefined) {
                await addFormParam('ReferenceDate', referenceDate, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: importsEntitlementsBatchImportRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/figgo/api/public/services/v1.0/leaveEntitlementsImport',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the progress of Import leaves API request.
         * @summary Get import leaves progress
         * @param {string} summaryId Identifier of the import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgress: async (summaryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'summaryId' is not null or undefined
            assertParamExists('getProgress', 'summaryId', summaryId)
            const localVarPath = `/timmi-absences/api/imports/v1.0/leavePeriods/{summaryId}/progress`
                .replace(`{${"summaryId"}}`, encodeURIComponent(String(summaryId !== undefined ? summaryId : `-summaryId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timmi-absences/api/imports/v1.0/leavePeriods/{summaryId}/progress',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements
         * @param {boolean} [strict] In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
         * @param {boolean} [simulate] Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
         * @param {string} [file] 
         * @param {string} [description] Description of the entries generated by the import (visible to users in the account details).
         * @param {string} [referenceDate] Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
         * @param {ImportsImportLeaveEntitlementsRequest} [importsImportLeaveEntitlementsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLeaveEntitlements: async (strict?: boolean, simulate?: boolean, file?: string, description?: string, referenceDate?: string, importsImportLeaveEntitlementsRequest?: ImportsImportLeaveEntitlementsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timmi-absences/api/public/services/v1.0/leaveEntitlementsImport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (simulate !== undefined) {
                localVarQueryParameter['simulate'] = simulate;
            }


            if (file !== undefined) {
                await addFormParam('File', file, false, true)
            }
    
            if (description !== undefined) {
                await addFormParam('Description', description, false, true)
            }
    
            if (referenceDate !== undefined) {
                await addFormParam('ReferenceDate', referenceDate, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: importsImportLeaveEntitlementsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timmi-absences/api/public/services/v1.0/leaveEntitlementsImport',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements (deprecated)
         * @param {boolean} [strict] In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
         * @param {boolean} [simulate] Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
         * @param {string} [file] 
         * @param {string} [description] Description of the entries generated by the import (visible to users in the account details).
         * @param {string} [referenceDate] Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
         * @param {string} [entryTypes] Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: &#x60;AutoAccruals, ManualAccruals, Regularizations&#x60; which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations).
         * @param {ImportsReplaceEntitlementsRequest} [importsReplaceEntitlementsRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        replaceEntitlements: async (strict?: boolean, simulate?: boolean, file?: string, description?: string, referenceDate?: string, entryTypes?: string, importsReplaceEntitlementsRequest?: ImportsReplaceEntitlementsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/figgo/api/public/services/v1.0/leaveEntitlementsReplace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (simulate !== undefined) {
                localVarQueryParameter['simulate'] = simulate;
            }


            if (file !== undefined) {
                await addFormParam('File', file, false, true)
            }
    
            if (description !== undefined) {
                await addFormParam('Description', description, false, true)
            }
    
            if (referenceDate !== undefined) {
                await addFormParam('ReferenceDate', referenceDate, false, true)
            }
    
            if (entryTypes !== undefined) {
                await addFormParam('EntryTypes', entryTypes, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: importsReplaceEntitlementsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/figgo/api/public/services/v1.0/leaveEntitlementsReplace',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements
         * @param {boolean} [strict] In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
         * @param {boolean} [simulate] Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
         * @param {string} [file] 
         * @param {string} [description] Description of the entries generated by the import (visible to users in the account details).
         * @param {string} [referenceDate] Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
         * @param {string} [entryTypes] Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: &#x60;AutoAccruals, ManualAccruals, Regularizations&#x60; which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations).
         * @param {ImportsReplaceEntitlementsRequest1} [importsReplaceEntitlementsRequest1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceEntitlements_1: async (strict?: boolean, simulate?: boolean, file?: string, description?: string, referenceDate?: string, entryTypes?: string, importsReplaceEntitlementsRequest1?: ImportsReplaceEntitlementsRequest1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timmi-absences/api/public/services/v1.0/leaveEntitlementsReplace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication Authorization required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authorization", configuration })
            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (simulate !== undefined) {
                localVarQueryParameter['simulate'] = simulate;
            }


            if (file !== undefined) {
                await addFormParam('File', file, false, true)
            }
    
            if (description !== undefined) {
                await addFormParam('Description', description, false, true)
            }
    
            if (referenceDate !== undefined) {
                await addFormParam('ReferenceDate', referenceDate, false, true)
            }
    
            if (entryTypes !== undefined) {
                await addFormParam('EntryTypes', entryTypes, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: importsReplaceEntitlementsRequest1,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timmi-absences/api/public/services/v1.0/leaveEntitlementsReplace',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportsApi - functional programming interface
 * @export
 */
export const ImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**   **File format**  Type: CSV (with semicolon \";\")  Encoding: UTF-8   All the following fields must be present with the field name in the header:  - legalEntity : establishment of the employee - employeeNumber : employee number - lastName : last name of the employee - firstName : firstname of the employee - accountId : absence account id in Timmi Absences (you can find it in the leave accounts admin page) - startDate : absence start date (DD/MM/YYYY) - flagStartDate : AM (if the absences starts in the morning) or PM (if the absence starts in the afternoon) - endDate : absence end date (DD/MM/YYYY) - flagEndDate : AM (if the absences ends at noon) or PM (if the absences ends in the afternoon) - isApproved : yes or no. Compulsory if the absence type is subject to approval, optional otherwise.  **History** Import history is available in the import module, including imports made using the API. 
         * @summary Import leaves (deprecated)
         * @param {ImportsApiAbsenceBatchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async absenceBatchCreate(requestParameters: ImportsApiAbsenceBatchCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsAbsenceBatchCreateResponse>> {
            const body: object = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.absenceBatchCreate(requestParameters.type, requestParameters.originalFileName, requestParameters.create, requestParameters.recredit, requestParameters.synchronize, requestParameters.overrideLeaves, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**  **File format**  Content-Type: CSV. Column divider is semicolon \";\". Line breaks between rows.  Encoding: UTF-8  All the following fields must be present with the field name in the header:  - legalEntity: Name of the establishment the employee belongs to. - employeeNumber: Employee number. - lastName: Family (last) name of the employee. - firstName: Given (first) name of the employee. - accountId: Identifier of the absence account in Timmi Absences (can be found in the leave accounts admin page). - startDate: Start date of the absence, formatted as `DD/MM/YYYY`. - flagStartDate: `\"AM\"` if the absence starts in the morning or `\"PM\"` if the absence starts in the afternoon. - endDate: End date of the absence, formatted as `DD/MM/YYYY`. - flagEndDate: `\"AM\"` if the absence ends at noon or `\"PM\"` if the absence ends in the afternoon. - isApproved: `true` or `false`. Dictates whether the absence request should be created and already approved.    Required if the type of the absence requires approval, optional otherwise.  **History** Import history is available in the import module. It includes imports made via the API. 
         * @summary Import leaves
         * @param {ImportsApiCreateAbsencesBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAbsencesBatch(requestParameters: ImportsApiCreateAbsencesBatchRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsCreateAbsencesBatchResponse>> {
            const importsCreateAbsencesBatchRequest: ImportsCreateAbsencesBatchRequest = {
                files: requestParameters.files
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAbsencesBatch(requestParameters.create, requestParameters.recredit, requestParameters.originalFileName, requestParameters.synchronize, requestParameters.async, requestParameters.files, importsCreateAbsencesBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements (deprecated)
         * @param {ImportsApiEntitlementsBatchImportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async entitlementsBatchImport(requestParameters: ImportsApiEntitlementsBatchImportRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsEntitlementsBatchImportResponse>> {
            const importsEntitlementsBatchImportRequest: ImportsEntitlementsBatchImportRequest = {
                File: requestParameters.File,
                Description: requestParameters.Description,
                ReferenceDate: requestParameters.ReferenceDate
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.entitlementsBatchImport(requestParameters.strict, requestParameters.simulate, requestParameters.file, requestParameters.description, requestParameters.referenceDate, importsEntitlementsBatchImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the progress of Import leaves API request.
         * @summary Get import leaves progress
         * @param {ImportsApiGetProgressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgress(requestParameters: ImportsApiGetProgressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgress(requestParameters.summaryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements
         * @param {ImportsApiImportLeaveEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importLeaveEntitlements(requestParameters: ImportsApiImportLeaveEntitlementsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsEntitlementsBatchImportResponse>> {
            const importsImportLeaveEntitlementsRequest: ImportsImportLeaveEntitlementsRequest = {
                File: requestParameters.File,
                Description: requestParameters.Description,
                ReferenceDate: requestParameters.ReferenceDate
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.importLeaveEntitlements(requestParameters.strict, requestParameters.simulate, requestParameters.file, requestParameters.description, requestParameters.referenceDate, importsImportLeaveEntitlementsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements (deprecated)
         * @param {ImportsApiReplaceEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async replaceEntitlements(requestParameters: ImportsApiReplaceEntitlementsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsEntitlementsBatchImportResponse>> {
            const importsReplaceEntitlementsRequest: ImportsReplaceEntitlementsRequest = {
                File: requestParameters.File,
                Description: requestParameters.Description,
                ReferenceDate: requestParameters.ReferenceDate,
                EntryTypes: requestParameters.EntryTypes
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceEntitlements(requestParameters.strict, requestParameters.simulate, requestParameters.file, requestParameters.description, requestParameters.referenceDate, requestParameters.entryTypes, importsReplaceEntitlementsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements
         * @param {ImportsApiReplaceEntitlements0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceEntitlements_1(requestParameters: ImportsApiReplaceEntitlements0Request = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportsEntitlementsBatchImportResponse>> {
            const importsReplaceEntitlementsRequest1: ImportsReplaceEntitlementsRequest1 = {
                File: requestParameters.File,
                Description: requestParameters.Description,
                ReferenceDate: requestParameters.ReferenceDate,
                EntryTypes: requestParameters.EntryTypes
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceEntitlements_1(requestParameters.strict, requestParameters.simulate, requestParameters.file, requestParameters.description, requestParameters.referenceDate, requestParameters.entryTypes, importsReplaceEntitlementsRequest1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportsApi - factory interface
 * @export
 */
export const ImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportsApiFp(configuration)
    return {
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**   **File format**  Type: CSV (with semicolon \";\")  Encoding: UTF-8   All the following fields must be present with the field name in the header:  - legalEntity : establishment of the employee - employeeNumber : employee number - lastName : last name of the employee - firstName : firstname of the employee - accountId : absence account id in Timmi Absences (you can find it in the leave accounts admin page) - startDate : absence start date (DD/MM/YYYY) - flagStartDate : AM (if the absences starts in the morning) or PM (if the absence starts in the afternoon) - endDate : absence end date (DD/MM/YYYY) - flagEndDate : AM (if the absences ends at noon) or PM (if the absences ends in the afternoon) - isApproved : yes or no. Compulsory if the absence type is subject to approval, optional otherwise.  **History** Import history is available in the import module, including imports made using the API. 
         * @summary Import leaves (deprecated)
         * @param {ImportsApiAbsenceBatchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        absenceBatchCreate(requestParameters: ImportsApiAbsenceBatchCreateRequest, options?: AxiosRequestConfig): AxiosPromise<ImportsAbsenceBatchCreateResponse> {
            return localVarFp.absenceBatchCreate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**  **File format**  Content-Type: CSV. Column divider is semicolon \";\". Line breaks between rows.  Encoding: UTF-8  All the following fields must be present with the field name in the header:  - legalEntity: Name of the establishment the employee belongs to. - employeeNumber: Employee number. - lastName: Family (last) name of the employee. - firstName: Given (first) name of the employee. - accountId: Identifier of the absence account in Timmi Absences (can be found in the leave accounts admin page). - startDate: Start date of the absence, formatted as `DD/MM/YYYY`. - flagStartDate: `\"AM\"` if the absence starts in the morning or `\"PM\"` if the absence starts in the afternoon. - endDate: End date of the absence, formatted as `DD/MM/YYYY`. - flagEndDate: `\"AM\"` if the absence ends at noon or `\"PM\"` if the absence ends in the afternoon. - isApproved: `true` or `false`. Dictates whether the absence request should be created and already approved.    Required if the type of the absence requires approval, optional otherwise.  **History** Import history is available in the import module. It includes imports made via the API. 
         * @summary Import leaves
         * @param {ImportsApiCreateAbsencesBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbsencesBatch(requestParameters: ImportsApiCreateAbsencesBatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ImportsCreateAbsencesBatchResponse> {
            return localVarFp.createAbsencesBatch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements (deprecated)
         * @param {ImportsApiEntitlementsBatchImportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        entitlementsBatchImport(requestParameters: ImportsApiEntitlementsBatchImportRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ImportsEntitlementsBatchImportResponse> {
            return localVarFp.entitlementsBatchImport(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the progress of Import leaves API request.
         * @summary Get import leaves progress
         * @param {ImportsApiGetProgressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgress(requestParameters: ImportsApiGetProgressRequest, options?: AxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getProgress(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Import entitlements
         * @param {ImportsApiImportLeaveEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLeaveEntitlements(requestParameters: ImportsApiImportLeaveEntitlementsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ImportsEntitlementsBatchImportResponse> {
            return localVarFp.importLeaveEntitlements(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements (deprecated)
         * @param {ImportsApiReplaceEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        replaceEntitlements(requestParameters: ImportsApiReplaceEntitlementsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ImportsEntitlementsBatchImportResponse> {
            return localVarFp.replaceEntitlements(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
         * @summary Replace entitlements
         * @param {ImportsApiReplaceEntitlements0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceEntitlements_1(requestParameters: ImportsApiReplaceEntitlements0Request = {}, options?: AxiosRequestConfig): AxiosPromise<ImportsEntitlementsBatchImportResponse> {
            return localVarFp.replaceEntitlements_1(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for absenceBatchCreate operation in ImportsApi.
 * @export
 * @interface ImportsApiAbsenceBatchCreateRequest
 */
export type ImportsApiAbsenceBatchCreateRequest = {
    
    /**
    * Support CSV files only
    * @type {'csv'}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly type: 'csv'
    
    /**
    * Filename
    * @type {string}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly originalFileName: string
    
    /**
    * Use `false` to simulate the import.
    * @type {boolean}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly create?: boolean
    
    /**
    * Use `true` if absences should **not** be deducted from the user balance. Use `false` if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case.
    * @type {boolean}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly recredit?: boolean
    
    /**
    * Use `true` to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use `false` to import absences without synchronizing absences.
    * @type {boolean}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly synchronize?: boolean
    
    /**
    * Use `true` to allow replacing existing absences
    * @type {boolean}
    * @memberof ImportsApiAbsenceBatchCreate
    */
    readonly overrideLeaves?: boolean
    
} & object

/**
 * Request parameters for createAbsencesBatch operation in ImportsApi.
 * @export
 * @interface ImportsApiCreateAbsencesBatchRequest
 */
export type ImportsApiCreateAbsencesBatchRequest = {
    
    /**
    * Use `false` to simulate the import.
    * @type {boolean}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly create?: boolean
    
    /**
    * Use `true` if absences should **not** be deducted from the user balance. Use `false` if absences should be deducted from the user balance. Note: if the absence type doesn’t have balance management, absence won’t impact the balance in any case.
    * @type {boolean}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly recredit?: boolean
    
    /**
    * Filename
    * @type {string}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly originalFileName?: string
    
    /**
    * Use `true` to force synchronization of the absences in the sync webservice (sync to Exchange/0365, Google Calendar, Webhook or ADP GXP, depending on configuration). Use `false` to import absences without synchronizing absences.
    * @type {boolean}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly synchronize?: boolean
    
    /**
    * Use `true` if you want to import absences with the asynchronous processing (you have to request figgo/api/imports/v1.0/leavePeriods/{summaryId}/progress API to track the status). Use `false` if you want import absences with the synchronous processing (the response is sent when the file is fully imported).
    * @type {boolean}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly async?: boolean
    
    /**
    * 
    * @type {Array<string>}
    * @memberof ImportsApiCreateAbsencesBatch
    */
    readonly files?: Array<string>
    
} & ImportsCreateAbsencesBatchRequest

/**
 * Request parameters for entitlementsBatchImport operation in ImportsApi.
 * @export
 * @interface ImportsApiEntitlementsBatchImportRequest
 */
export type ImportsApiEntitlementsBatchImportRequest = {
    
    /**
    * In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
    * @type {boolean}
    * @memberof ImportsApiEntitlementsBatchImport
    */
    readonly strict?: boolean
    
    /**
    * Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
    * @type {boolean}
    * @memberof ImportsApiEntitlementsBatchImport
    */
    readonly simulate?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof ImportsApiEntitlementsBatchImport
    */
    readonly file?: string
    
    /**
    * Description of the entries generated by the import (visible to users in the account details).
    * @type {string}
    * @memberof ImportsApiEntitlementsBatchImport
    */
    readonly description?: string
    
    /**
    * Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
    * @type {string}
    * @memberof ImportsApiEntitlementsBatchImport
    */
    readonly referenceDate?: string
    
} & ImportsEntitlementsBatchImportRequest

/**
 * Request parameters for getProgress operation in ImportsApi.
 * @export
 * @interface ImportsApiGetProgressRequest
 */
export type ImportsApiGetProgressRequest = {
    
    /**
    * Identifier of the import
    * @type {string}
    * @memberof ImportsApiGetProgress
    */
    readonly summaryId: string
    
}

/**
 * Request parameters for importLeaveEntitlements operation in ImportsApi.
 * @export
 * @interface ImportsApiImportLeaveEntitlementsRequest
 */
export type ImportsApiImportLeaveEntitlementsRequest = {
    
    /**
    * In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
    * @type {boolean}
    * @memberof ImportsApiImportLeaveEntitlements
    */
    readonly strict?: boolean
    
    /**
    * Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
    * @type {boolean}
    * @memberof ImportsApiImportLeaveEntitlements
    */
    readonly simulate?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof ImportsApiImportLeaveEntitlements
    */
    readonly file?: string
    
    /**
    * Description of the entries generated by the import (visible to users in the account details).
    * @type {string}
    * @memberof ImportsApiImportLeaveEntitlements
    */
    readonly description?: string
    
    /**
    * Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
    * @type {string}
    * @memberof ImportsApiImportLeaveEntitlements
    */
    readonly referenceDate?: string
    
} & ImportsImportLeaveEntitlementsRequest

/**
 * Request parameters for replaceEntitlements operation in ImportsApi.
 * @export
 * @interface ImportsApiReplaceEntitlementsRequest
 */
export type ImportsApiReplaceEntitlementsRequest = {
    
    /**
    * In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
    * @type {boolean}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly strict?: boolean
    
    /**
    * Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
    * @type {boolean}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly simulate?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly file?: string
    
    /**
    * Description of the entries generated by the import (visible to users in the account details).
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly description?: string
    
    /**
    * Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly referenceDate?: string
    
    /**
    * Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: `AutoAccruals, ManualAccruals, Regularizations` which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations).
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements
    */
    readonly entryTypes?: string
    
} & ImportsReplaceEntitlementsRequest

/**
 * Request parameters for replaceEntitlements_1 operation in ImportsApi.
 * @export
 * @interface ImportsApiReplaceEntitlements0Request
 */
export type ImportsApiReplaceEntitlements0Request = {
    
    /**
    * In strict mode, if the import has errors, nothing is imported. Without strict mode, the lines in error are ignored and those in success are imported.
    * @type {boolean}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly strict?: boolean
    
    /**
    * Allows you to simulate the import. In this case, the response indicates the theoretical result of the import without any data being recorded.
    * @type {boolean}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly simulate?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly file?: string
    
    /**
    * Description of the entries generated by the import (visible to users in the account details).
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly description?: string
    
    /**
    * Reference date (text mode). Respect the format: yyyy-MM-ddThh: mm: ss
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly referenceDate?: string
    
    /**
    * Types of entries to take into account, separated by commas, from the following list: AutoAccruals, ManualAccruals, Regularisations, EntitlementsImport, Seniority, Fractionnement, TimeSavings, Comp  By default: `AutoAccruals, ManualAccruals, Regularizations` which correspond to the main cases of acquisition (automatic acquisition, manual adjustments, regularisations).
    * @type {string}
    * @memberof ImportsApiReplaceEntitlements0
    */
    readonly entryTypes?: string
    
} & ImportsReplaceEntitlementsRequest1

/**
 * ImportsApiGenerated - object-oriented interface
 * @export
 * @class ImportsApiGenerated
 * @extends {BaseAPI}
 */
export class ImportsApiGenerated extends BaseAPI {
    /**
     * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**   **File format**  Type: CSV (with semicolon \";\")  Encoding: UTF-8   All the following fields must be present with the field name in the header:  - legalEntity : establishment of the employee - employeeNumber : employee number - lastName : last name of the employee - firstName : firstname of the employee - accountId : absence account id in Timmi Absences (you can find it in the leave accounts admin page) - startDate : absence start date (DD/MM/YYYY) - flagStartDate : AM (if the absences starts in the morning) or PM (if the absence starts in the afternoon) - endDate : absence end date (DD/MM/YYYY) - flagEndDate : AM (if the absences ends at noon) or PM (if the absences ends in the afternoon) - isApproved : yes or no. Compulsory if the absence type is subject to approval, optional otherwise.  **History** Import history is available in the import module, including imports made using the API. 
     * @summary Import leaves (deprecated)
     * @param {ImportsApiAbsenceBatchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public absenceBatchCreate(requestParameters: ImportsApiAbsenceBatchCreateRequest, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).absenceBatchCreate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create absences in batch from a CSV file.  **Important notice: Absence imports cannot be cancelled.**   In case of a mistake absences must be deleted manually through the interface or using the API (see Use cases). **Use import with care!**  **File format**  Content-Type: CSV. Column divider is semicolon \";\". Line breaks between rows.  Encoding: UTF-8  All the following fields must be present with the field name in the header:  - legalEntity: Name of the establishment the employee belongs to. - employeeNumber: Employee number. - lastName: Family (last) name of the employee. - firstName: Given (first) name of the employee. - accountId: Identifier of the absence account in Timmi Absences (can be found in the leave accounts admin page). - startDate: Start date of the absence, formatted as `DD/MM/YYYY`. - flagStartDate: `\"AM\"` if the absence starts in the morning or `\"PM\"` if the absence starts in the afternoon. - endDate: End date of the absence, formatted as `DD/MM/YYYY`. - flagEndDate: `\"AM\"` if the absence ends at noon or `\"PM\"` if the absence ends in the afternoon. - isApproved: `true` or `false`. Dictates whether the absence request should be created and already approved.    Required if the type of the absence requires approval, optional otherwise.  **History** Import history is available in the import module. It includes imports made via the API. 
     * @summary Import leaves
     * @param {ImportsApiCreateAbsencesBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public createAbsencesBatch(requestParameters: ImportsApiCreateAbsencesBatchRequest = {}, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).createAbsencesBatch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @summary Import entitlements (deprecated)
     * @param {ImportsApiEntitlementsBatchImportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public entitlementsBatchImport(requestParameters: ImportsApiEntitlementsBatchImportRequest = {}, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).entitlementsBatchImport(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the progress of Import leaves API request.
     * @summary Get import leaves progress
     * @param {ImportsApiGetProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public getProgress(requestParameters: ImportsApiGetProgressRequest, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).getProgress(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @summary Import entitlements
     * @param {ImportsApiImportLeaveEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public importLeaveEntitlements(requestParameters: ImportsApiImportLeaveEntitlementsRequest = {}, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importLeaveEntitlements(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @summary Replace entitlements (deprecated)
     * @param {ImportsApiReplaceEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public replaceEntitlements(requestParameters: ImportsApiReplaceEntitlementsRequest = {}, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).replaceEntitlements(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Supported file formats:** - CSV   - \"UTF-8\" encoding   - separator “;” - XSLX  **Columns to fill in:**  Column name | Description --- | --- LegalEntityCode | Employee legal entity code EmployeeNumber | Employee payroll number LastName | Last name FirstName | First name Account number or name (one column per account) | Value to import for the account defined in the header.   *Remark: A template file can be downloaded from the import page (Credit / Debit> A group of collaborators> File import).*  In the event of a malformed (or unrecognized) file, no data will be imported; the problems detected will be specified in the `globalErrors` field.  If successful, the number of imported lines is indicated by the “successLinesCount” field; the lines in error are detailed in the `lineErrors` field.   *Remarks: Any import made by the API is of course available in the import history. A simulation returns the same level of information, but does not trigger an import*  **List of errors handled**  Here is the list of fatal errors, which can be returned in the `globalErrors`: - Unauthorized - FileEmpty, - FileExtensionNotSupported, - ColumnsFormatNotSupported, - AccountColumnMissing, - ColumnNamesDistinct, - LineErrorForbiddenInStrictMode,  The list of line processing errors, which can be restored in the `lineErrors`: - AccountNotFound, - AccountsNotFound, - AccountColumnsProcessing, - LegalEntityCodesNotFound, - MissingValuesForAccount, - AccountNotAvailableForUser, - LegalEntityCodeRequired, - EmployeeNumberRequired, - LoginRequired, - LoginNotFound, - AccountNumberRequired, - LegalEntityNotFound, - EmployeeNumberNotExist, - EmployeeNumberNotInLegalEntity, - FistNameAndLastNameNotMatching, - FistNameNotMatching, - LastLameNotMatching, - FistNameAndLastNameNotMatchingEmployeeNumber, - FistNameNotMatchingEmployeeNumber, - LastLameNotMatchingEmployeeNumber, - FistNameAndLastNameNotMatchingLogin, - FistNameNotMatchingLogin, - LastLameNotMatchingLogin, - DuplicatedLine, - AmbiguousLegalEntity, - ColumnNotExists, - LegalEntityNameNotAvailable, - AccountNameNotUnique  The list of import generation errors: - UnableToCreditAccount 
     * @summary Replace entitlements
     * @param {ImportsApiReplaceEntitlements0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApiGenerated
     */
    public replaceEntitlements_1(requestParameters: ImportsApiReplaceEntitlements0Request = {}, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).replaceEntitlements_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
